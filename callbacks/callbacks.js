/**
 * LOOTER.AI CLONE - CALLBACKS HANDLER
 * All button interactions exactly like Looter.ai
 * üöÄ UPDATED: Removed authentication - All users can now trade!
 */

const WalletUI = require('./wallet-ui');
const TradingUI = require('./trading-ui');
const BuyTokenUI = require('./buy-token-ui');

class Callbacks {
  constructor(bot, auth, walletManager, trading, userStates, chainManager) {
    this.bot = bot;
    this.auth = auth;
    this.walletManager = walletManager;
    this.trading = trading;
    this.userStates = userStates;
    this.chainManager = chainManager;
    
    // UI helpers
    this.walletUI = new WalletUI(bot, walletManager, userStates);
    this.tradingUI = new TradingUI(bot, trading);
    this.buyTokenUI = new BuyTokenUI(bot, walletManager, chainManager);
  }

  // Main callback handler
  async handle(callbackQuery) {
    const { data, from, message } = callbackQuery;
    const chatId = from.id;
    const messageId = message.message_id;
    let acknowledged = false;

    try {
      // Helper function to acknowledge callback only once
      const acknowledge = async (text = null, showAlert = false) => {
        if (!acknowledged) {
          try {
            await this.bot.answerCallbackQuery(callbackQuery.id, {
              text: text,
              show_alert: showAlert
            });
            acknowledged = true;
          } catch (ackError) {
            console.error('‚ùå Failed to acknowledge callback:', ackError.message);
          }
        }
      };

      // üö® IMMEDIATELY acknowledge callback to prevent timeout
      await acknowledge();
      
      // üöÄ REMOVED AUTHENTICATION - Allow all users to trade
      console.log(`üéâ User ${chatId} (${from?.username || 'unknown'}) accessing callback: ${data}`);

      // Auto-create user if doesn't exist
      await this.walletManager.ensureUserExists(chatId, from);

      console.log(`üîò ========== CALLBACK RECEIVED ==========`);
      console.log(`üîò Data: ${data}`);
      console.log(`üîò From user: ${chatId}`);
      console.log(`üîò Message ID: ${messageId}`);
      console.log(`üîò =======================================`);
      
      // Route callbacks to appropriate handlers
      if (data === 'main_menu') {
        await this.handleMainMenu(chatId, messageId);
      }
      
      // Wallet management
      else if (data === 'wallets_menu') {
        await this.walletUI.showChainSelection(chatId, messageId);
      }
      else if (data.startsWith('chain_')) {
        const chain = data.replace('chain_', '');
        await this.walletUI.showWalletManagement(chatId, messageId, chain);
      }
      else if (data.startsWith('wallet_')) {
        await this.walletUI.handleWalletAction(callbackQuery);
      }
      
      // üî• WALLET SELECTION FOR TRADING (ws_ callbacks)
      else if (data.startsWith('ws_')) {
        console.log('üî• WALLET SELECT DETECTED! Data:', data);
        await this.handleWalletSelect(callbackQuery);
      }
      
      // Trading actions
      else if (data === 'buy_menu') {
        await this.buyTokenUI.handleBuyTokenMenu(chatId, messageId);
      }
      else if (data.startsWith('buy_select_amount_')) {
        await this.handleBuySelectAmount(callbackQuery);
      }
      else if (data.startsWith('buy_confirm_new_')) {
        await this.handleBuyConfirmNew(callbackQuery);
      }
      else if (data.startsWith('buy_refresh_')) {
        await this.handleBuyRefresh(callbackQuery);
      }
      else if (data.startsWith('buy_custom_')) {
        await this.handleBuyCustom(callbackQuery);
      }
      else if (data.startsWith('slippage_')) {
        await this.handleSlippage(callbackQuery);
      }
      else if (data.startsWith('gas_')) {
        await this.handleGas(callbackQuery);
      }
      // üí∞ NEW: Speed tier selection
      else if (data.startsWith('speed_')) {
        await this.handleSpeedTier(callbackQuery);
      }
      else if (data.startsWith('buy_')) {
        await this.handleBuyAction(callbackQuery);
      }
      else if (data === 'sell_menu') {
        await this.handleSellMenu(chatId, messageId);
      }
      else if (data === 'snipe_menu') {
        await this.handleSnipeMenu(chatId, messageId);
      }
      else if (data === 'limit_menu') {
        await this.handleLimitMenu(chatId, messageId);
      }
      
      // Portfolio
      else if (data === 'portfolio_menu') {
        await this.handlePortfolio(chatId, messageId);
      }
      
      // Settings
      else if (data === 'settings_menu') {
        await this.handleSettings(chatId, messageId);
      }
      
      // Help
      else if (data === 'help_menu') {
        await this.handleHelp(chatId, messageId);
      }
      
      // Expert mode
      else if (data.startsWith('expert_')) {
        await this.handleExpertMode(callbackQuery);
      }
      
      // Unknown callback
      else {
        console.log('‚ùì Unknown callback received:', data);
        await this.handleUnknown(callbackQuery);
      }

    } catch (error) {
      console.error('‚ùå Callback error:', error.message);
      
      // Acknowledge callback even if there was an error
      if (!acknowledged) {
        try {
          await this.bot.answerCallbackQuery(callbackQuery.id, {
            text: '‚ùå An error occurred. Please try again.',
            show_alert: false
          });
        } catch (answerError) {
          console.error('‚ùå Failed to answer callback query:', answerError.message);
        }
      }
    }
  }

  // Handle wallet selection toggle (ws_ callbacks)
  async handleWalletSelect(callbackQuery) {
    const { from, message, data } = callbackQuery;
    const chatId = from.id;
    const messageId = message.message_id;

    try {
      console.log('üéØ WALLET SELECT CALLBACK:', data);
      
      // Parse callback data: ws_sessionId_walletNum
      const parts = data.split('_');
      console.log('üéØ PARSED PARTS:', parts);
      const sessionId = parts[1];  // t1, t2, etc.
      const walletNum = parseInt(parts[2]);  // 1, 2, 3, 4, 5
      
      console.log('üéØ SESSION ID:', sessionId);
      console.log('üéØ WALLET NUM:', walletNum);

      // Get token data from session
      const tokenData = this.buyTokenUI.getTokenSession(chatId, sessionId);
      console.log('üéØ TOKEN DATA FOUND:', !!tokenData);
      
      if (!tokenData) {
        console.log('‚ùå No token data found for session');
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: '‚ùå Session expired. Please try again.',
          show_alert: true
        });
        return;
      }

      // Toggle wallet selection
      const selectedWallets = this.buyTokenUI.toggleWallet(chatId, sessionId, walletNum);

      // Update the message with new wallet selection
      const walletBalances = await this.buyTokenUI.getUserWalletBalances(chatId, tokenData.chain);
      const tokenInfo = this.buyTokenUI.tokenAnalyzer.formatTokenInfo(tokenData, walletBalances);
      const buyKeyboard = await this.buyTokenUI.createBuyKeyboardWithSession(chatId, tokenData, sessionId);

      await this.bot.editMessageText(tokenInfo, {
        chat_id: chatId,
        message_id: messageId,
        parse_mode: 'Markdown',
        reply_markup: buyKeyboard,
        disable_web_page_preview: true
      });

      const selectedCount = selectedWallets.size;
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: `${selectedWallets.has(walletNum) ? '‚úÖ' : '‚ùå'} W${walletNum} ${selectedWallets.has(walletNum) ? 'selected' : 'deselected'} (${selectedCount}/5)`
      });

    } catch (error) {
      console.error('‚ùå Error handling wallet selection:', error.message);
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: '‚ùå Error updating wallet selection',
        show_alert: true
      });
    }
  }

  // Handle buy amount selection
  async handleBuySelectAmount(callbackQuery) {
    const { data } = callbackQuery;
    const chatId = callbackQuery.from.id;
    
    console.log('üí∞ BUY AMOUNT SELECTED:', data);
    
    try {
      // Parse: buy_select_amount_sessionId_amount
      const parts = data.split('_');
      const sessionId = parts[3]; // t1, t2, etc.
      const amount = parseFloat(parts[4]); // 0.01, 0.05, etc.
      
      console.log(`üí∞ Amount ${amount} ETH selected for session ${sessionId}`);
      
      // Store the selected amount in the buyTokenUI
      this.buyTokenUI.setSelectedAmount(chatId, sessionId, amount);
      
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: `üí∞ ${amount} ETH selected! Now select wallets and click CONFIRM.`
      });
      
    } catch (error) {
      console.error('‚ùå Error handling amount selection:', error.message);
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: '‚ùå Error selecting amount',
        show_alert: true
      });
    }
  }

  // Handle buy confirmation
  async handleBuyConfirmNew(callbackQuery) {
    const { data } = callbackQuery;
    const chatId = callbackQuery.from.id;
    const messageId = callbackQuery.message.message_id;
    
    console.log('‚úÖ BUY CONFIRM CLICKED:', data);
    
    try {
      // Parse: buy_confirm_new_sessionId
      const parts = data.split('_');
      const sessionId = parts[3]; // t1, t2, etc.
      
      // Get token data and selected options
      const tokenData = this.buyTokenUI.getTokenSession(chatId, sessionId);
      const selectedWallets = this.buyTokenUI.getSelectedWallets(chatId, sessionId);
      const selectedAmount = this.buyTokenUI.getSelectedAmount(chatId, sessionId);
      // üí∞ NEW: Get selected speed tier
      const speedTier = this.buyTokenUI.getSpeedTier(chatId, sessionId);
      
      if (!tokenData) {
        await this.bot.sendMessage(chatId, '‚ùå Session expired. Please try again.');
        return;
      }
      
      if (selectedWallets.size === 0) {
        await this.bot.sendMessage(chatId, '‚ùå Please select at least one wallet first!');
        return;
      }
      
      if (!selectedAmount) {
        await this.bot.sendMessage(chatId, '‚ùå Please select an amount first!');
        return;
      }
      
      // üöÄ IMMEDIATELY show execution starting message
      await this.bot.sendMessage(chatId, 
        `üöÄ **EXECUTING TRADE**\n\n` +
        `ü™ô Token: ${tokenData.symbol}\n` +
        `üí∞ Amount: ${selectedAmount} ETH\n` +
        `‚è≥ Processing...`, 
        { parse_mode: 'Markdown' }
      );
      
      // Execute the buy using Multi-DEX Base Trading system (async, don't wait for callback ack)
      this.executeBuyTrade(callbackQuery, tokenData, selectedAmount, selectedWallets, sessionId, speedTier)
        .catch(error => {
          console.error('‚ùå Error in async buy execution:', error.message);
          this.bot.sendMessage(chatId, `‚ùå Trade failed: ${error.message}`);
        });
      
    } catch (error) {
      console.error('‚ùå Error in buy confirmation:', error.message);
      await this.bot.sendMessage(chatId, `‚ùå Error executing buy: ${error.message}`);
    }
  }

  // Execute the actual buy trade
  async executeBuyTrade(callbackQuery, tokenData, amount, selectedWallets, sessionId, speedTier = 'standard') {
    const chatId = callbackQuery.from.id;
    const messageId = callbackQuery.message.message_id;
    
    try {
      console.log('üöÄ EXECUTING BUY TRADE...');
      console.log(`Token: ${tokenData.symbol} (${tokenData.address})`);
      console.log(`Amount: ${amount} ETH`);
      console.log(`Wallets: ${Array.from(selectedWallets).join(', ')}`);
      console.log(`üí∞ Speed Tier: ${speedTier}`);
      
      // üí∞ Calculate platform fee based on speed tier
      const feeCalc = this.buyTokenUI.calculatePlatformFee(amount, speedTier);
      const speedConfig = this.buyTokenUI.getSpeedTierConfig(speedTier);
      
      console.log(`üí∞ Platform fee calculation:`);
      console.log(`  - Gross amount: ${feeCalc.grossAmount} ETH`);
      console.log(`  - Platform fee: ${feeCalc.feeAmount} ETH (${feeCalc.feePercent}%)`);
      console.log(`  - Net trade amount: ${feeCalc.netAmount} ETH`);
      
      // Show execution message
      await this.bot.editMessageText(
        `üöÄ **Executing ${speedConfig.name} Buy Order...**\n\n` +
        `ü™ô **Token:** ${tokenData.name} (${tokenData.symbol})\n` +
        `üí∞ **Amount:** ${amount} ETH per wallet\n` +
        `üè¶ **Wallets:** ${Array.from(selectedWallets).map(w => `W${w}`).join(', ')}\n` +
        `‚õìÔ∏è **Chain:** Base Network\n` +
        `${speedConfig.icon} **Speed:** ${speedConfig.name} (${speedConfig.feePercent}% fee)\n` +
        `üí∞ **Platform Fee:** ${feeCalc.feeAmount} ETH\n` +
        `üíµ **Net Trade:** ${feeCalc.netAmount} ETH\n\n` +
        `‚è≥ **Processing transaction(s)...**\n` +
        `üîÑ **Please wait for confirmation...**`, {
        chat_id: chatId,
        message_id: messageId,
        parse_mode: 'Markdown'
      });
      
      // Get user wallets for Base chain
      const chainWallets = await this.walletManager.getChainWallets(chatId, 'base');
      
      let successCount = 0;
      let failCount = 0;
      const results = [];
      
      // Execute buy for each selected wallet
      for (const walletNum of selectedWallets) {
        const walletSlot = `W${walletNum}`;
        const wallet = chainWallets[walletSlot];
        
        if (!wallet || !wallet.privateKey) {
          console.log(`‚ùå Wallet ${walletSlot} not found or missing private key`);
          failCount++;
          continue;
        }
        
        try {
          console.log(`üîÑ Executing trade with wallet ${walletSlot}: ${wallet.address}`);
          
          // üöÄ USE OUR BASE TRADING SERVICE WITH FEE COLLECTION
          console.log(`üí∞ Using BaseTrading service with fee collection enabled`);
          console.log(`üîç this.trading exists: ${!!this.trading}`);
          console.log(`üîç this.trading.baseTrading exists: ${!!this.trading?.baseTrading}`);
          console.log(`üîç typeof this.trading.baseTrading: ${typeof this.trading?.baseTrading}`);
          console.log(`üîç execBuyWithFee method exists: ${!!this.trading?.baseTrading?.execBuyWithFee}`);
          
          // List all available methods on baseTrading
          if (this.trading?.baseTrading) {
            console.log(`üîç Available methods on baseTrading:`, Object.getOwnPropertyNames(Object.getPrototypeOf(this.trading.baseTrading)));
            console.log(`üîç All properties on baseTrading:`, Object.keys(this.trading.baseTrading));
          }
          
          if (!this.trading || !this.trading.baseTrading) {
            throw new Error('BaseTrading service is not available in callbacks');
          }
          
          if (typeof this.trading.baseTrading.execBuyWithFee !== 'function') {
            throw new Error('execBuyWithFee method is not available on baseTrading service');
          }
          
          // üí∞ Execute trade using our fee collection system
          // This will automatically deduct fees and transfer them to treasury wallet
          console.log(`üöÄ Executing tiered trade with fee collection...`);
          console.log(`  üí∞ Token: ${tokenData.address}`);
          console.log(`  üí∞ Amount: ${amount} ETH`);
          console.log(`  ‚ö° Speed Tier: ${speedTier} (${speedTier === 'fast' ? '0.5%' : speedTier === 'instant' ? '1.0%' : '0.3%'} fee)`);
          
          // üí∞ Execute trade with 30-second timeout using the correct method
          console.log(`üöÄ Starting execBuyWithFee with 30s timeout...`);
          
          // Calculate fee info for the trade
          const feeCalc = this.buyTokenUI.calculatePlatformFee(amount, speedTier);
          const speedConfig = this.buyTokenUI.getSpeedTierConfig(speedTier);
          
          console.log(`üí∞ Using execBuyWithFee method with fee info:`, {
            grossAmount: feeCalc.grossAmount,
            feeAmount: feeCalc.feeAmount,
            netAmount: feeCalc.netAmount,
            feePercent: feeCalc.feePercent
          });
          
          const result = await Promise.race([
            this.trading.baseTrading.execBuyWithFee({
              privateKey: wallet.privateKey,
              tokenOut: tokenData.address,
              amountEth: amount, // Gross amount
              slippageBps: 2500, // 25% slippage
              feeTier: 3000, // 0.3% pool fee
              userTier: speedTier.toUpperCase() + '_TIER',
              feeInfo: {
                feeAmount: feeCalc.feeAmount,
                netAmount: feeCalc.netAmount,
                feePercent: feeCalc.feePercent
              },
              gasSettings: {
                gasPrice: speedConfig.gasPrice || 1000000000, // 1 gwei default
                gasLimit: speedConfig.gasLimit || 300000
              }
            }),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Trade execution timeout (30s)')), 30000)
            )
          ]);
          console.log(`‚úÖ execBuyWithFee completed successfully!`);
          
          if (result.success) {
            console.log(`‚úÖ Buy successful for ${walletSlot}: ${result.txHash}`);
            
            // Log fee transfer result
            if (result.feeTransfer) {
              if (result.feeTransfer.success && !result.feeTransfer.skipped) {
                console.log(`üí≥ Fee transfer successful: ${result.feeInfo.feeAmount} ETH ‚Üí Treasury`);
              } else {
                console.log(`üí∞ Fee transfer skipped: ${result.feeTransfer.reason || 'unknown'}`);
              }
            }
            
            results.push({
              wallet: walletSlot,
              success: true,
              txHash: result.txHash,
              explorerUrl: result.explorerUrl,
              // üí∞ Actual fee information from our system
              feeInfo: result.feeInfo,
              feeTransfer: result.feeTransfer,
              userTier: result.userTier,
              gasUsed: result.gasUsed
            });
            successCount++;
          } else {
            console.log(`‚ùå Buy failed for ${walletSlot}: ${result.error}`);
            results.push({
              wallet: walletSlot,
              success: false,
              error: result.error
            });
            failCount++;
          }
          
        } catch (error) {
          console.error(`‚ùå Exception during buy for ${walletSlot}:`, error.message);
          results.push({
            wallet: walletSlot,
            success: false,
            error: error.message
          });
          failCount++;
        }
      }
      
      // Show results with safe message formatting
      let resultMessage = `üéâ **Buy Order Complete!**\n\n`;
      resultMessage += `üìä **Summary:**\n`;
      resultMessage += `‚Ä¢ ‚úÖ Successful: ${successCount}\n`;
      resultMessage += `‚Ä¢ ‚ùå Failed: ${failCount}\n\n`;
      
      if (successCount > 0) {
        resultMessage += `‚úÖ **Successful Transactions:**\n`;
        results.filter(r => r.success).forEach(r => {
          // Safe formatting for links and special characters
          const txHashShort = r.txHash ? r.txHash.substring(0, 10) + '...' : 'N/A';
          resultMessage += `‚Ä¢ **${r.wallet}:** \`${txHashShort}\`\n`;
        });
        resultMessage += '\n';
        
        // Add transaction links in a safe way
        resultMessage += `üîó **View on BaseScan:**\n`;
        results.filter(r => r.success).forEach(r => {
          if (r.txHash) {
            resultMessage += `${r.wallet}: https://basescan.org/tx/${r.txHash}\n`;
          }
        });
        resultMessage += '\n';
      }
      
      if (failCount > 0) {
        resultMessage += `‚ùå **Failed Transactions:**\n`;
        results.filter(r => !r.success).forEach(r => {
          // Clean error messages to avoid special characters
          const cleanError = r.error.replace(/[_*\[\]()~`>#+=|{}.!-]/g, '').substring(0, 100);
          resultMessage += `‚Ä¢ **${r.wallet}:** ${cleanError}\n`;
        });
      }
      
      await this.bot.editMessageText(resultMessage, {
        chat_id: chatId,
        message_id: messageId,
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ Buy More', callback_data: `buy_refresh_${sessionId}` },
              { text: 'üè† Main Menu', callback_data: 'main_menu' }
            ]
          ]
        },
        disable_web_page_preview: true
      });
      
      // Best-effort: callback queries expire quickly; ignore errors
      try {
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: `üéâ ${successCount} successful, ${failCount} failed`
        });
      } catch (ackErr) {
        console.warn('‚ö†Ô∏è CallbackQuery expired or invalid, ignoring:', ackErr.message);
      }
      
    } catch (error) {
      console.error('‚ùå Error executing buy trade:', error.message);
      
      await this.bot.editMessageText(
        `‚ùå **Buy Order Failed**\n\n` +
        `üí• **Error:** ${error.message}\n\n` +
        `üí° **Please try again or contact support**`, {
        chat_id: chatId,
        message_id: messageId,
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [
              { text: 'üîÑ Try Again', callback_data: `buy_refresh_${sessionId}` },
              { text: 'üè† Main Menu', callback_data: 'main_menu' }
            ]
          ]
        }
      });
    }
  }

  // Placeholder handlers for other actions
  async handleBuyRefresh(callbackQuery) {
    await this.bot.answerCallbackQuery(callbackQuery.id, {
      text: 'üîÑ Refresh functionality coming soon!',
      show_alert: true
    });
  }

  async handleBuyCustom(callbackQuery) {
    const { data } = callbackQuery;
    const chatId = callbackQuery.from.id;
    const messageId = callbackQuery.message.message_id;
    
    console.log('üí∞ BUY CUSTOM AMOUNT CLICKED:', data);
    
    try {
      // Parse: buy_custom_sessionId
      const parts = data.split('_');
      const sessionId = parts[2]; // t1, t2, etc.
      
      console.log(`üí∞ Setting up custom amount input for session ${sessionId}`);
      
      // Get token data for context
      const tokenData = this.buyTokenUI.getTokenSession(chatId, sessionId);
      
      if (!tokenData) {
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: '‚ùå Session expired. Please try again.',
          show_alert: true
        });
        return;
      }
      
      // Set user state to expect custom amount input using UserStates class
      this.userStates.setCustomAmountState(chatId, {
        sessionId: sessionId,
        tokenData: tokenData,
        messageId: messageId
      });
      
      // Show custom amount input message
      const inputMessage = 
        `üí∞ **Custom Amount Input**\n\n` +
        `ü™ô **Token:** ${tokenData.name} (${tokenData.symbol})\n` +
        `‚õìÔ∏è **Chain:** Base Network\n\n` +
        `üí° **Please enter the amount of ETH you want to spend:**\n\n` +
        `**Examples:**\n` +
        `‚Ä¢ \`0.01\` - Spend 0.01 ETH\n` +
        `‚Ä¢ \`0.05\` - Spend 0.05 ETH\n` +
        `‚Ä¢ \`0.1\` - Spend 0.1 ETH\n` +
        `‚Ä¢ \`1.5\` - Spend 1.5 ETH\n\n` +
        `‚ö†Ô∏è **Note:** Amount will be spent from each selected wallet\n\n` +
        `üìù **Type your amount and send it as a message:**`;
      
      const keyboard = {
        inline_keyboard: [
          [
            { text: '‚ùå Cancel', callback_data: `buy_refresh_${sessionId}` }
          ]
        ]
      };
      
      await this.bot.editMessageText(inputMessage, {
        chat_id: chatId,
        message_id: messageId,
        parse_mode: 'Markdown',
        reply_markup: keyboard
      });
      
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: 'üí∞ Please type your custom amount in ETH'
      });
      
    } catch (error) {
      console.error('‚ùå Error handling custom amount input:', error.message);
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: '‚ùå Error setting up custom amount input',
        show_alert: true
      });
    }
  }

  async handleSlippage(callbackQuery) {
    await this.bot.answerCallbackQuery(callbackQuery.id, {
      text: 'üìä Slippage settings coming soon!',
      show_alert: true
    });
  }

  async handleGas(callbackQuery) {
    await this.bot.answerCallbackQuery(callbackQuery.id, {
      text: '‚õΩ Gas settings coming soon!',
      show_alert: true
    });
  }

  // üí∞ Handle speed tier selection
  async handleSpeedTier(callbackQuery) {
    const { data, from, message } = callbackQuery;
    const chatId = from.id;
    const messageId = message.message_id;
    
    try {
      // Parse: speed_sessionId_tier
      const parts = data.split('_');
      const sessionId = parts[1]; // t1, t2, etc.
      const tier = parts[2]; // standard, fast, instant
      
      console.log(`üí∞ Speed tier selected: ${tier} for session ${sessionId}`);
      
      // Set the speed tier
      this.buyTokenUI.setSpeedTier(chatId, sessionId, tier);
      
      // Get tier config for confirmation
      const config = this.buyTokenUI.getSpeedTierConfig(tier);
      
      // Update the buy interface to show the new selection
      const tokenData = this.buyTokenUI.getTokenSession(chatId, sessionId);
      
      if (!tokenData) {
        await this.bot.answerCallbackQuery(callbackQuery.id, {
          text: '‚ùå Session expired. Please try again.',
          show_alert: true
        });
        return;
      }
      
      // Refresh the buy interface
      const walletBalances = await this.buyTokenUI.getUserWalletBalances(chatId, tokenData.chain);
      const tokenInfo = this.buyTokenUI.tokenAnalyzer.formatTokenInfo(tokenData, walletBalances);
      const buyKeyboard = await this.buyTokenUI.createBuyKeyboardWithSession(chatId, tokenData, sessionId);
      
      await this.bot.editMessageText(tokenInfo, {
        chat_id: chatId,
        message_id: messageId,
        parse_mode: 'Markdown',
        reply_markup: buyKeyboard,
        disable_web_page_preview: true
      });
      
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: `${config.icon} ${config.name} selected! Fee: ${config.feePercent}% | ${config.description}`
      });
      
    } catch (error) {
      console.error('‚ùå Error handling speed tier selection:', error.message);
      await this.bot.answerCallbackQuery(callbackQuery.id, {
        text: '‚ùå Error setting speed tier',
        show_alert: true
      });
    }
  }

  async handleMainMenu(chatId, messageId) {
    const welcomeMessage = 
      `üè† **Looter.ai Clone - Main Menu**\n\n` +
      `üéØ **Ready to trade? Choose an option below:**\n\n` +
      `‚Ä¢ üî• **Buy Token** - Instant token purchases\n` +
      `‚Ä¢ üí∏ **Sell Tokens** - Manage your positions\n` +
      `‚Ä¢ üéØ **Snipe Orders** - Catch new launches\n` +
      `‚Ä¢ üìä **Limit Orders** - Set target prices\n` +
      `‚Ä¢ üíº **Manage Wallets** - Your trading wallets\n` +
      `‚Ä¢ üìà **Portfolio** - Track your performance`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üî• Buy Token', callback_data: 'buy_menu' },
          { text: 'üí∏ Sell Tokens', callback_data: 'sell_menu' }
        ],
        [
          { text: 'üéØ Snipe Orders', callback_data: 'snipe_menu' },
          { text: 'üìä Limit Orders', callback_data: 'limit_menu' }
        ],
        [
          { text: 'üíº Manage Wallets', callback_data: 'wallets_menu' },
          { text: 'üìà Portfolio', callback_data: 'portfolio_menu' }
        ],
        [
          { text: '‚öôÔ∏è Settings', callback_data: 'settings_menu' },
          { text: 'üÜò Help', callback_data: 'help_menu' }
        ]
      ]
    };

    await this.bot.editMessageText(welcomeMessage, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async handleBuyAction(callbackQuery) {
    await this.bot.answerCallbackQuery(callbackQuery.id, {
      text: 'üî• Buy functionality with Multi-DEX Base Trading (Uniswap V3, Aerodrome, SushiSwap, PancakeSwap, BaseSwap)!',
      show_alert: true
    });
  }

  async handleSellMenu(chatId, messageId) {
    const message = 
      `üí∏ **Sell Tokens**\n\n` +
      `üìä **Your Positions:**\n` +
      `_No positions found_\n\n` +
      `üí° *Buy some tokens first to see positions here*`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîÑ Refresh', callback_data: 'sell_menu' },
          { text: 'üîô Back to Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async handleSnipeMenu(chatId, messageId) {
    const message = 
      `üéØ **Snipe Orders**\n\n` +
      `üöÄ **Active Snipe Orders:**\n` +
      `_No active snipe orders_\n\n` +
      `üí° *Create snipe orders to catch new token launches*`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: '‚ûï Create Snipe', callback_data: 'snipe_create' },
          { text: 'üìã View All', callback_data: 'snipe_view' }
        ],
        [
          { text: 'üîô Back to Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async handleLimitMenu(chatId, messageId) {
    const message = 
      `üìä **Limit Orders**\n\n` +
      `üìà **Active Limit Orders:**\n` +
      `_No active limit orders_\n\n` +
      `üí° *Set target prices for automatic trading*`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: '‚ûï Create Limit Order', callback_data: 'limit_create' },
          { text: 'üìã View All', callback_data: 'limit_view' }
        ],
        [
          { text: 'üîô Back to Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async handlePortfolio(chatId, messageId) {
    const message = 
      `üìà **Your Portfolio**\n\n` +
      `üí∞ **Total Value:** $0.00\n` +
      `üìä **P&L Today:** $0.00 (0%)\n` +
      `üéØ **Active Positions:** 0\n\n` +
      `üîÑ **Recent Trades:**\n` +
      `_No trades yet_\n\n` +
      `üí° *Start trading to see your portfolio here*`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üîÑ Refresh', callback_data: 'portfolio_menu' },
          { text: 'üìä Detailed View', callback_data: 'portfolio_detailed' }
        ],
        [
          { text: 'üîô Back to Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async handleSettings(chatId, messageId) {
    const message = 
      `‚öôÔ∏è **Bot Settings**\n\n` +
      `üîß **Current Settings:**\n` +
      `‚Ä¢ Default Chain: Base\n` +
      `‚Ä¢ Slippage: 1.0%\n` +
      `‚Ä¢ Gas Limit: 500,000\n` +
      `‚Ä¢ MEV Protection: Enabled\n` +
      `‚Ä¢ Auto Refresh: Enabled\n\n` +
      `üí° *Customize your trading experience*`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: '‚õìÔ∏è Default Chain', callback_data: 'settings_chain' },
          { text: 'üíß Slippage', callback_data: 'settings_slippage' }
        ],
        [
          { text: '‚õΩ Gas Settings', callback_data: 'settings_gas' },
          { text: 'üõ°Ô∏è MEV Protection', callback_data: 'settings_mev' }
        ],
        [
          { text: 'üîô Back to Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async handleHelp(chatId, messageId) {
    const message = 
      `üÜò **Looter.ai Clone - Help & Guide**\n\n` +
      `**üöÄ Getting Started:**\n` +
      `1. Choose "Manage Wallets" to set up your trading wallets\n` +
      `2. Select a blockchain network\n` +
      `3. Generate or import wallets\n` +
      `4. Start trading with "Buy Token"\n\n` +
      `**üí° Expert Mode:**\n` +
      `Send: \`TOKEN_ADDRESS AMOUNT TIP\`\n` +
      `Example: \`0x1234...5678 0.1 0.01\`\n\n` +
      `**üîó Supported Chains:**\n` +
      `Ethereum, Base, BSC, Arbitrum, Polygon, Avalanche, Solana, Blast, Optimism\n\n` +
      `**üõ°Ô∏è Security:**\n` +
      `‚Ä¢ Private keys stored securely\n` +
      `‚Ä¢ MEV protection enabled\n` +
      `‚Ä¢ Secure wallet management`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: 'üìñ User Guide', callback_data: 'help_guide' },
          { text: '‚ùì FAQ', callback_data: 'help_faq' }
        ],
        [
          { text: 'üîô Back to Main Menu', callback_data: 'main_menu' }
        ]
      ]
    };

    await this.bot.editMessageText(message, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: keyboard
    });
  }

  async handleExpertMode(callbackQuery) {
    await this.bot.answerCallbackQuery(callbackQuery.id, {
      text: 'üéØ Expert mode coming soon!',
      show_alert: true
    });
  }

  async handleUnknown(callbackQuery) {
    const { data, from, message } = callbackQuery;
    const chatId = from.id;
    const messageId = message.message_id;

    console.log(`‚ö†Ô∏è Unknown callback: ${data} from user ${chatId}`);

    await this.bot.editMessageText(
      `üöß **Feature Coming Soon!**\n\n` +
      `This feature is being developed and will be available soon.\n\n` +
      `Thank you for your patience!`, {
      chat_id: chatId,
      message_id: messageId,
      parse_mode: 'Markdown',
      reply_markup: {
        inline_keyboard: [
          [{ text: 'üîô Back to Main Menu', callback_data: 'main_menu' }]
        ]
      }
    });
  }

  // Placeholder message handlers
  async handleWalletImport(msg) {
    const chatId = msg.chat.id;
    await this.walletManager.ensureUserExists(chatId, msg.from);
    await this.walletUI.handleWalletImport(msg);
  }

  async handleTransferMessage(msg) {
    const chatId = msg.chat.id;
    await this.walletManager.ensureUserExists(chatId, msg.from);
    await this.bot.sendMessage(chatId, 'üí∏ Transfer functionality coming soon!');
  }

  async handleCustomAmountMessage(msg) {
    const chatId = msg.chat.id;
    await this.walletManager.ensureUserExists(chatId, msg.from);
    
    // Check if user is waiting for custom amount input
    const userState = this.userStates.getState(chatId);
    
    if (!userState || userState.action !== 'waiting_for_custom_amount') {
      // Not waiting for custom amount - ignore this message
      return;
    }
    
    const sessionId = userState.sessionId;
    const amountText = msg.text.trim();
    
    console.log(`üí∞ Processing custom amount input: "${amountText}" for session ${sessionId}`);
    
    try {
      // Validate the amount
      const amount = parseFloat(amountText);
      
      if (isNaN(amount) || amount <= 0) {
        await this.bot.sendMessage(chatId, 
          `‚ùå **Invalid Amount**\n\n` +
          `Please enter a valid positive number.\n` +
          `Example: \`0.1\` for 0.1 ETH\n\n` +
          `üìù Try again:`, {
          parse_mode: 'Markdown'
        });
        return;
      }
      
      if (amount > 100) {
        await this.bot.sendMessage(chatId,
          `‚ö†Ô∏è **Amount Too Large**\n\n` +
          `Maximum amount is 100 ETH for safety.\n` +
          `Please enter a smaller amount.\n\n` +
          `üìù Try again:`, {
          parse_mode: 'Markdown'
        });
        return;
      }
      
      // Amount is valid - store it and show the buy interface again
      this.buyTokenUI.setSelectedAmount(chatId, sessionId, amount);
      
      // Clear the user state
      this.userStates.clearState(chatId);
      
      // Get token data
      const tokenData = this.buyTokenUI.getTokenSession(chatId, sessionId);
      
      if (!tokenData) {
        await this.bot.sendMessage(chatId,
          `‚ùå **Session Expired**\n\n` +
          `Please start a new token purchase.`, {
          parse_mode: 'Markdown'
        });
        return;
      }
      
      // Show success message and return to buy interface
      await this.bot.sendMessage(chatId,
        `‚úÖ **Custom Amount Set**\n\n` +
        `üí∞ **Amount:** ${amount} ETH\n` +
        `ü™ô **Token:** ${tokenData.symbol}\n\n` +
        `Now select your wallets and click CONFIRM to execute the trade!`, {
        parse_mode: 'Markdown'
      });
      
      // Update the buy interface to show the new amount
      const walletBalances = await this.buyTokenUI.getUserWalletBalances(chatId, tokenData.chain);
      const tokenInfo = this.buyTokenUI.tokenAnalyzer.formatTokenInfo(tokenData, walletBalances);
      const buyKeyboard = await this.buyTokenUI.createBuyKeyboardWithSession(chatId, tokenData, sessionId, amount);
      
      await this.bot.sendMessage(chatId, tokenInfo, {
        parse_mode: 'Markdown',
        reply_markup: buyKeyboard,
        disable_web_page_preview: true
      });
      
    } catch (error) {
      console.error('‚ùå Error processing custom amount:', error.message);
      
      await this.bot.sendMessage(chatId,
        `‚ùå **Error Processing Amount**\n\n` +
        `There was an error processing your amount.\n` +
        `Please try again or use the preset amounts.`, {
        parse_mode: 'Markdown'
      });
      
      // Clear the user state
      this.userStates.clearState(chatId);
    }
  }

  async handleCustomSlippageInput(msg) {
    const chatId = msg.chat.id;
    await this.walletManager.ensureUserExists(chatId, msg.from);
    await this.bot.sendMessage(chatId, 'üìä Custom slippage functionality coming soon!');
  }
}

module.exports = Callbacks;